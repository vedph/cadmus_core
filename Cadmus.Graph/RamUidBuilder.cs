using System;
using System.Collections.Concurrent;
using System.Threading;

namespace Cadmus.Graph;

/// <summary>
/// RAM-based UID builder. This is essentially used for diagnostic or
/// demo purposes.
/// </summary>
public sealed class RamUidBuilder : IUidBuilder
{
    private static int _nextId;

    // key=unsuffixed UID, value=has suffix + suffix number
    private static readonly ConcurrentDictionary<string, Tuple<bool, int, string>>
        _lookup = new();

    /// <summary>
    /// Build the eventually suffixed UID.
    /// </summary>
    /// <param name="unsuffixed">The UID as calculated from its source,
    /// without any suffix. If the caller wants a unique new UID for it, it
    /// must be suffixed with <c>##</c>: this suffix will be either removed
    /// when no entry is present with the same <paramref name="unsuffixed"/>
    /// value, or replaced by a numeric suffix preceded by <c>#</c> to grant
    /// its uniqueness.</param>
    /// <param name="sid">The source ID (SID).</param>
    /// <returns>UID, eventually suffixed with #N.</returns>
    /// <exception cref="ArgumentException">sid or unsuffixed</exception>
    public string BuildUid(string unsuffixed, string sid)
    {
        if (string.IsNullOrEmpty(sid))
            throw new ArgumentException(nameof(sid));
        if (string.IsNullOrEmpty(unsuffixed))
            throw new ArgumentException(nameof(unsuffixed));

        // special case: unsuffixed ending with ## means that the caller
        // wants a unique suffix to be added to the unsuffixed UID
        bool unique = false;
        if (unsuffixed.EndsWith("##", StringComparison.Ordinal))
        {
            unique = true;
            unsuffixed = unsuffixed[..^2];
        }

        // if unsuffixed does not exist, just add and return it
        if (!_lookup.ContainsKey(unsuffixed.ToLowerInvariant()))
        {
            _lookup[unsuffixed.ToLowerInvariant()] = Tuple.Create(
                false,
                Interlocked.Increment(ref _nextId),
                sid);
        }

        // found and not unique: reuse it with its suffix if any,
        // nothing gets inserted
        if (!unique)
        {
            Tuple<bool, int, string> entry = _lookup[unsuffixed.ToLowerInvariant()];
            return entry.Item1 ? unsuffixed + "#" + entry.Item2 : unsuffixed;
        }

        // else make it unique by adding a new suffixed entry: the suffix
        // will be the autogenerated ID of the new entry
        int id = Interlocked.Increment(ref _nextId);
        _lookup[unsuffixed.ToLowerInvariant()] = Tuple.Create(true, id, sid);
        return $"{unsuffixed}#{id}";
    }
}
